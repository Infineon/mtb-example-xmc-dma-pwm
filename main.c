/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the XMC MCU: DMA PWM Example for
*              ModusToolbox. This example demonstrates how to use DMA double
*              buffering with the PWM Block.
*
* Related Document: See README.md
*
*******************************************************************************
*
* Copyright (c) 2015 - 2022, Infineon Technologies AG
* All rights reserved.
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
*****************************************************************************/

/*******************************************************************************
 * Include header files
 ******************************************************************************/
 
#include "cybsp.h"
#include "cy_utils.h"
#include "cy_retarget_io.h"

/*******************************************************************************
* Macros
*******************************************************************************/

#define BLOCK_SIZE        48
#define TIMER_PERIOD      65535
#define COMPARE_BLOCK     TIMER_PERIOD/BLOCK_SIZE

/* Define macro to enable/disable printing of debug messages */
#define ENABLE_XMC_DEBUG_PRINT (0)

/*******************************************************************************
* Variables
*******************************************************************************/

uint32_t shadow_transfer_enable;
uint32_t duty_cycles[2][BLOCK_SIZE];

uint32_t *src_ptr = &shadow_transfer_enable;

#if (UC_SERIES == XMC43)
uint32_t *dst_ptr = (uint32_t *)&(CCU41->GCSS);
#else
uint32_t *dst_ptr = (uint32_t *)&(CCU40->GCSS);
#endif

/* DMA linked list to transfer the data from memory to CCU4 peripheral. 
 * - The block size must be set to the transfer block size defined by the 
 *   macro BLOCK_SIZE
 * - Source address is the RAM buffer duty_cycle, and destination is the CCU4 
 *   compare register CRS.
 * - The linked list pointer points to the next DMA linked list to be 
 *   transferred.
 * - The source and destination transfer width must be 32 to enable 32 bit 
 *   transfers.
 * - Source address count mode should be configured to increment after every 
 *   data transfer and the destination count mode should not change as data 
 *   is written to the same register.
 * - Transfer flow is memory to peripheral (RAM to CCU4).
 */
__attribute__((aligned(32))) XMC_DMA_LLI_t dma_ll[2] =
{
  {
    .block_size = BLOCK_SIZE,                                            /* Transfer Block size */
    .src_addr = (uint32_t)&duty_cycles[0][0],                            /* Source address */
    .dst_addr = (uint32_t)&PWM_0_HW->CRS,                                /* Destination address */
    .llp = &dma_ll[1],                                                   /* Linked list pointer of type XMC_DMA_LLI_t */
    .src_transfer_width = XMC_DMA_CH_TRANSFER_WIDTH_32,                  /* Source transfer width */
    .dst_transfer_width = XMC_DMA_CH_TRANSFER_WIDTH_32,                  /* Destination transfer width */
    .src_address_count_mode = XMC_DMA_CH_ADDRESS_COUNT_MODE_INCREMENT,   /* Source address count mode */
    .dst_address_count_mode = XMC_DMA_CH_ADDRESS_COUNT_MODE_NO_CHANGE,   /* Destination address count mode */
    .src_burst_length = XMC_DMA_CH_BURST_LENGTH_1,                       /* Source burst length */
    .dst_burst_length = XMC_DMA_CH_BURST_LENGTH_1,                       /* Destination burst length */
    .transfer_flow = XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA,                   /* DMA Transfer flow */
    .enable_src_linked_list = true,                                      /* Enable source linked list? */
    .enable_dst_linked_list = true,                                      /* Enable destination linked list? */
  },
  {
    .block_size = BLOCK_SIZE,                                            /* Transfer Block size */
    .src_addr = (uint32_t)&duty_cycles[1][0],                            /* Source address */
    .dst_addr = (uint32_t)&PWM_0_HW->CRS,                                /* Destination address */
    .llp = &dma_ll[0],                                                   /* Linked list pointer of type XMC_DMA_LLI_t */
    .src_transfer_width = XMC_DMA_CH_TRANSFER_WIDTH_32,                  /* Source transfer width */
    .dst_transfer_width = XMC_DMA_CH_TRANSFER_WIDTH_32,                  /* Destination transfer width */
    .src_address_count_mode = XMC_DMA_CH_ADDRESS_COUNT_MODE_INCREMENT,   /* Source address count mode */
    .dst_address_count_mode = XMC_DMA_CH_ADDRESS_COUNT_MODE_NO_CHANGE,   /* Destination address count mode */
    .src_burst_length = XMC_DMA_CH_BURST_LENGTH_1,                       /* Source burst length */
    .dst_burst_length = XMC_DMA_CH_BURST_LENGTH_1,                       /* Destination burst length */
    .transfer_flow = XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA,                   /* DMA Transfer flow */
    .enable_src_linked_list = true,                                      /* Enable source linked list? */
    .enable_dst_linked_list = true,                                      /* Enable destination linked list? */
  }
};

XMC_DMA_LLI_t *LLP = &dma_ll[0];

/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
* This is the main function. This function sets up the CCU4 peripheral and 
* initializes the GPDMA peripheral.
*
* Parameters:
*  none
*
* Return:
*  int
*
*******************************************************************************/

int main(void)
{
    cy_rslt_t result;
    cy_retarget_io_init(CYBSP_DEBUG_UART_HW);
    
    /*Initialize the device and board peripherals */
    result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    #if ENABLE_XMC_DEBUG_PRINT
        printf("Init complete\r\n");
    #endif

    for(int i = 0; i < BLOCK_SIZE; i++)
    {
        duty_cycles[0][i] = COMPARE_BLOCK * i ;
        duty_cycles[1][i] = (COMPARE_BLOCK * (BLOCK_SIZE - 1)) - (COMPARE_BLOCK * i);
    }

    /* Set the shadow transfer enable variable that sets the shadow transfer
     * bit in the CCU40 GCSS register
     */
    shadow_transfer_enable = CCU4_GCSS_S0SE_Msk;

    /* Enable the DMA channel to initiate transfer */
    XMC_DMA_CH_Enable(DMA_CH0_HW, DMA_CH0_NUM);
    XMC_DMA_CH_Enable(DMA_CH1_HW, DMA_CH1_NUM);

    /* Start the PWM */
    XMC_CCU4_SLICE_StartTimer(PWM_0_HW);
  
    #if ENABLE_XMC_DEBUG_PRINT
        printf("Timer started\r\n");
    #endif

    /* Placeholder for user application code. The while loop below can be 
     * replaced with user application code. 
     */
    while(1U);
}
/* [] END OF FILE */
